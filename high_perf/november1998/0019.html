<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>High Performance Alpha Linux: how to optimize dgemm? No.1</TITLE>
<META NAME="Author" CONTENT="Kazushige Goto (goto@statabo.rim.or.jp)">
<META NAME="Subject" CONTENT="how to optimize dgemm? No.1">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>how to optimize dgemm? No.1</H1>
<HR>
<P>
<!-- received="Mon Nov 30 22:10:02 1998 EST" -->
<!-- sent="Mon, 30 Nov 1998 23:19:31 +0900" -->
<!-- name="Kazushige Goto" -->
<!-- email="goto@statabo.rim.or.jp" -->
<!-- subject="how to optimize dgemm? No.1" -->
<!-- id="19981130231931B.goto@statabo.rim.or.jp" -->
<!-- inreplyto="" -->
<STRONG>Kazushige Goto</STRONG> (<A HREF="mailto:goto@statabo.rim.or.jp?subject=Re:%20how%20to%20optimize%20dgemm?%20No.1"><EM>goto@statabo.rim.or.jp</EM></A>)<BR>
<EM>Mon, 30 Nov 1998 23:19:31 +0900</EM>
<P>
<UL>
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#19">[ date ]</A>
<A HREF="index.html#19">[ thread ]</A>
<A HREF="subject.html#19">[ subject ]</A>
<A HREF="author.html#19">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0020.html">Johannes G.D. Hausmann: "First shot at fastmath-rpm with new libffm.0.28"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0018.html">Richard Gorton: "Re: Questions on performance methods"</A>
<!-- nextthread="start" -->
</UL>
<HR>
<!-- body="start" -->
<P>
Recently, some people asked me how to optimize my dgemm routine.
<BR>
I wrote some information in dgemm_k.S source code, but it's not
<BR>
enough.
<BR>
<P>So, I decided to explain some opimization method of Alpha step by
<BR>
step. Because it takes too long to explain.
<BR>
<P>First, I make a sample &amp; simple benchmark program.  Please try to type 
<BR>
&quot;make&quot; and benchmark show you actual speed with MFlops.
<BR>
<P>I explain only Non-transposed x Non-transposed routine.  If you have
<BR>
any questions, please tell me.
<BR>
<P>Originally, BLAS dgemm kernel routine is programmed as follows.
<BR>
It's really pretty simple, but it takes too long(about 23MFlops,
<BR>
600MHz 21164).
<BR>
<P><P>void dgemm_nn(int m, int n, int k, double alpha, double *a,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lda, double *b, int ldb,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double *c, int ldc){
<BR>
<P>&nbsp;&nbsp;int i, j, l;
<BR>
<P>&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc] += alpha * b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
}
<BR>
<P><P>1. loop exchangeable
<BR>
<P>This dgemm_nn routine works fine even if any loop is exchanged.
<BR>
<P>&nbsp;&lt;&lt; 44MFLops &gt;&gt;
<BR>
<P>&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc] += alpha * b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P>or
<BR>
<P>&nbsp;&lt;&lt; 40MFLops &gt;&gt;
<BR>
<P>&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc] += alpha * b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P>or
<BR>
....
<BR>
<P><P>So we can choose a loop to get best performance.
<BR>
<P><P>2. Inner dot product
<BR>
<P>A basic strategy of Alpha(also, all other RISC machines) is to
<BR>
&quot;calculate innder dot product routine&quot;.  Because &quot;store&quot; operation
<BR>
also causes data traffics.
<BR>
<P>It means,  we can choose one of this.
<BR>
<P>&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc] += alpha * b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P>or
<BR>
<P>&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc] += alpha * b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P>c[i+j*ldc] is a constant value in most inner loop.  So we can change
<BR>
it to 
<BR>
<P><P>&nbsp;&lt;&lt; 27MFLops &gt;&gt;
<BR>
<P>&nbsp;&nbsp;double temp;
<BR>
<P>&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = 0.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp += b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc ] += alpha * temp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P>or
<BR>
<P>&nbsp;&lt;&lt; 22MFLops &gt;&gt;
<BR>
<P>&nbsp;&nbsp;double temp;
<BR>
<P>&nbsp;&nbsp;for (j = 0; j &lt; n; j++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; m; i++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = 0.0;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (l = 0; l &lt; k; l++) {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp += b[l + j * ldb] * a[i + l * lda];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i + j * ldc ] += alpha * temp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;}
<BR>
<P><P>It's still slow, but it'll be much faster as optimizing dgemm_nn.
<BR>
<P>Continue to No.2
<BR>
<P>Thanks,
<BR>
&nbsp;&nbsp;<A HREF="mailto:goto@statabo.rim.or.jp?subject=Re:%20how%20to%20optimize%20dgemm?%20No.1">goto@statabo.rim.or.jp</A>
<BR>
<P><P><!-- attachment="gemm-1.tar.gz_" -->
<HR>
<UL>
<LI>Application/Octet-Stream attachment: <A HREF="gemm-1.tar.gz_">gemm-1.tar.gz_</A>
</UL>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0020.html">Johannes G.D. Hausmann: "First shot at fastmath-rpm with new libffm.0.28"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0018.html">Richard Gorton: "Re: Questions on performance methods"</A>
<!-- nextthread="start" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.landfield.com/hypermail/">hypermail 2.0b3</A> 
on <EM>Mon Nov 30 1998 - 22:10:34 EST</EM>
</EM>
</SMALL>
</BODY>
</HTML>
