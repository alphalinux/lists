<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>axp-list: [patches] patch-2.2.2-nonx86,patch-2.2.2-filter</TITLE>
<META NAME="Author" CONTENT="Daniel J. Frasnelli (dfrasnel@csee.wvu.edu)">
<META NAME="Subject" CONTENT="[patches] patch-2.2.2-nonx86,patch-2.2.2-filter">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>[patches] patch-2.2.2-nonx86,patch-2.2.2-filter</H1>
<HR>
<P>
<!-- received="Wed Feb 24 02:20:25 1999 PST" -->
<!-- sent="Tue, 23 Feb 1999 21:17:16 -0500" -->
<!-- name="Daniel J. Frasnelli" -->
<!-- email="dfrasnel@csee.wvu.edu" -->
<!-- subject="[patches] patch-2.2.2-nonx86,patch-2.2.2-filter" -->
<!-- id="19990223211716.B18379@csee.wvu.edu" -->
<!-- inreplyto="" -->
<STRONG>Daniel J. Frasnelli</STRONG> (<A HREF="mailto:dfrasnel@csee.wvu.edu?subject=Re:%20[patches]%20patch-2.2.2-nonx86,patch-2.2.2-filter"><EM>dfrasnel@csee.wvu.edu</EM></A>)<BR>
<EM>Tue, 23 Feb 1999 21:17:16 -0500</EM>
<P>
<UL>
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#702">[ date ]</A>
<A HREF="index.html#702">[ thread ]</A>
<A HREF="subject.html#702">[ subject ]</A>
<A HREF="author.html#702">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Previous message:</STRONG> <A HREF="0701.html">Bernard Chew, Lai Wan: "RE: Video cards"</A>
<!-- nextthread="start" -->
</UL>
<HR>
<!-- body="start" -->
<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So I pointed my browser over to www.alphalinux.org earlier today,
<BR>
and found this little item near the top:
<BR>
&nbsp;&nbsp;&nbsp;* February 23rd 1999
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The good news is that kernel 2.2.2 has been released. The bad news
<BR>
&nbsp;&nbsp;&nbsp;is that it does not compile on Alpha.                                        
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ah, how sad it was indeed.
<BR>
Maybe the two attached patches will brighten your day.  The first patch
<BR>
(nonx86) should take care of those nasty x86 semaphores like __down_trylock, 
<BR>
and the second (filter) should take care of, well, broken filter code. 
<BR>
I've had 2.2.2 running for approximately 7+ hours total today, so
<BR>
the patch appears to be safe. 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that it is not a comprehensive solution.  The final &quot;fix&quot;
<BR>
for this problem will be bringing semaphores on axp up to where x86 is
<BR>
right now.  We're working on that as well, but in the meantime this
<BR>
should allow building of 2.2.2.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I've tested this on my Alpha, but it should work for any non-x86
<BR>
platform.  I am currently compiling the 2.2.2ac1 kernel with the
<BR>
non-x86 patch applied, so I assume the patch fixes that one as well.
<BR>
<P>Enjoy,
<BR>
Daniel
<BR>
<PRE>
-- 
<P><P>
--- pristine/kernel/ksyms.c	Tue Feb 23 18:45:45 1999
+++ linux-2.2.2-axp/kernel/ksyms.c	Tue Feb 23 20:21:28 1999
@@ -322,8 +322,6 @@
 EXPORT_SYMBOL(sprintf);
 EXPORT_SYMBOL(vsprintf);
 EXPORT_SYMBOL(kdevname);
-EXPORT_SYMBOL(bdevname);
-EXPORT_SYMBOL(cdevname);
 EXPORT_SYMBOL(simple_strtoul);
 EXPORT_SYMBOL(system_utsname);	/* UTS data */
 EXPORT_SYMBOL(uts_sem);		/* UTS semaphore */
@@ -372,7 +370,6 @@
 EXPORT_SYMBOL(event);
 EXPORT_SYMBOL(__down);
 EXPORT_SYMBOL(__down_interruptible);
-EXPORT_SYMBOL(__down_trylock);
 EXPORT_SYMBOL(__up);
 EXPORT_SYMBOL(brw_page);
 
--- pristine/kernel/sched.c	Tue Feb 23 18:45:45 1999
+++ linux-2.2.2-axp/kernel/sched.c	Tue Feb 23 20:16:35 1999
@@ -36,7 +36,6 @@
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmu_context.h&gt;
-#include &lt;asm/semaphore-helper.h&gt;
 
 #include &lt;linux/timex.h&gt;
 
@@ -464,17 +463,8 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;timerlist_lock, flags);
-	if (timer-&gt;prev)
-		goto bug;
 	internal_add_timer(timer);
-out:
 	spin_unlock_irqrestore(&amp;timerlist_lock, flags);
-	return;
-
-bug:
-	printk(&quot;bug: kernel timer added twice at %p.\n&quot;,
-			__builtin_return_address(0));
-	goto out;
 }
 
 static inline int detach_timer(struct timer_list *timer)
@@ -873,28 +863,30 @@
 	struct task_struct *tsk = current;	\
 	struct wait_queue wait = { tsk, NULL };
 
-#define DOWN_HEAD(task_state)						\
-									\
-									\
-	tsk-&gt;state = (task_state);					\
-	add_wait_queue(&amp;sem-&gt;wait, &amp;wait);				\
-									\
-	/*								\
-	 * Ok, we're set up.  sem-&gt;count is known to be less than zero	\
-	 * so we must wait.						\
-	 *								\
-	 * We can let go the lock for purposes of waiting.		\
-	 * We re-acquire it after awaking so as to protect		\
-	 * all semaphore operations.					\
-	 *								\
-	 * If &quot;up()&quot; is called before we call waking_non_zero() then	\
-	 * we will catch it right away.  If it is called later then	\
-	 * we will have to go through a wakeup cycle to catch it.	\
-	 *								\
-	 * Multiple waiters contend for the semaphore lock to see	\
-	 * who gets to gate through and who has to wait some more.	\
-	 */								\
-	for (;;) {
+#define DOWN_HEAD(task_state)						 \
+									 \
+									 \
+	tsk-&gt;state = (task_state);					 \
+	add_wait_queue(&amp;sem-&gt;wait, &amp;wait);				 \
+									 \
+	/*								 \
+	 * Ok, we're set up.  sem-&gt;count is known to be less than zero	 \
+	 * so we must wait.						 \
+	 *								 \
+	 * We can let go the lock for purposes of waiting.		 \
+	 * We re-acquire it after awaking so as to protect		 \
+	 * all semaphore operations.					 \
+	 *								 \
+	 * If &quot;up()&quot; is called before we call waking_non_zero() then	 \
+	 * we will catch it right away.  If it is called later then	 \
+	 * we will have to go through a wakeup cycle to catch it.	 \
+	 *								 \
+	 * Multiple waiters contend for the semaphore lock to see	 \
+	 * who gets to gate through and who has to wait some more.	 \
+	 */								 \
+	for (;;) {							 \
+		if (waking_non_zero(sem, tsk))	/* are we waking up?  */ \
+			break;			/* yes, exit loop */
 
 #define DOWN_TAIL(task_state)			\
 		tsk-&gt;state = (task_state);	\
@@ -906,8 +898,6 @@
 {
 	DOWN_VAR
 	DOWN_HEAD(TASK_UNINTERRUPTIBLE)
-	if (waking_non_zero(sem))
-		break;
 	schedule();
 	DOWN_TAIL(TASK_UNINTERRUPTIBLE)
 }
@@ -917,23 +907,15 @@
 	DOWN_VAR
 	int ret = 0;
 	DOWN_HEAD(TASK_INTERRUPTIBLE)
-
-	ret = waking_non_zero_interruptible(sem, tsk);
-	if (ret)
+	if (signal_pending(tsk))
 	{
-		if (ret == 1)
-			/* ret != 0 only if we get interrupted -arca */
-			ret = 0;
+		ret = -EINTR;			/* interrupted */
+		atomic_inc(&amp;sem-&gt;count);	/* give up on down operation */
 		break;
 	}
 	schedule();
 	DOWN_TAIL(TASK_INTERRUPTIBLE)
 	return ret;
-}
-
-int __down_trylock(struct semaphore * sem)
-{
-	return waking_non_zero_trylock(sem);
 }
 
 #define	SLEEP_ON_VAR				\
<P><P>
--- pristine/net/core/filter.c	Tue Feb 23 18:45:45 1999
+++ linux-2.2.2-axp/net/core/filter.c	Tue Feb 23 20:16:35 1999
@@ -11,8 +11,6 @@
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
- *
- * Andi Kleen - Fix a few bad bugs and races.
  */
 
 #include &lt;linux/config.h&gt;
@@ -38,22 +36,6 @@
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/filter.h&gt;
 
-/* No hurry in this branch */
-
-static u8 *load_pointer(struct sk_buff *skb, int k)
-{
-	u8 *ptr = NULL;
-
-	if (k&gt;=SKF_NET_OFF)
-		ptr = skb-&gt;nh.raw + k - SKF_NET_OFF;
-	else if (k&gt;=SKF_LL_OFF)
-		ptr = skb-&gt;mac.raw + k - SKF_LL_OFF;
-
-	if (ptr&lt;skb-&gt;head &amp;&amp; ptr &lt; skb-&gt;tail)
-		return ptr;
-	return NULL;
-}
-
 /*
  * Decode and apply filter instructions to the skb-&gt;data.
  * Return length to keep, 0 for none. skb is the data we are
@@ -61,19 +43,15 @@
  * len is the number of filter blocks in the array.
  */
  
-int sk_run_filter(struct sk_buff *skb, struct sock_filter *filter, int flen)
+int sk_run_filter(unsigned char *data, int len, struct sock_filter *filter, int flen)
 {
-	unsigned char *data = skb-&gt;data;
-	/* len is UNSIGNED. Byte wide insns relies only on implicit
-	   type casts to prevent reading arbitrary memory locations.
-	 */
-	unsigned int len = skb-&gt;len;
 	struct sock_filter *fentry;	/* We walk down these */
 	u32 A = 0;	   		/* Accumulator */
 	u32 X = 0;   			/* Index Register */
 	u32 mem[BPF_MEMWORDS];		/* Scratch Memory Store */
 	int k;
 	int pc;
+	int *t;
 
 	/*
 	 * Process array of filter instructions.
@@ -82,75 +60,53 @@
 	for(pc = 0; pc &lt; flen; pc++)
 	{
 		fentry = &amp;filter[pc];
+		if(fentry-&gt;code &amp; BPF_X)
+			t=&amp;X;
+		else
+			t=&amp;fentry-&gt;k;
 			
 		switch(fentry-&gt;code)
 		{
 			case BPF_ALU|BPF_ADD|BPF_X:
-				A += X;
-				continue;
-
 			case BPF_ALU|BPF_ADD|BPF_K:
-				A += fentry-&gt;k;
+				A += *t;
 				continue;
 
 			case BPF_ALU|BPF_SUB|BPF_X:
-				A -= X;
-				continue;
-
 			case BPF_ALU|BPF_SUB|BPF_K:
-				A -= fentry-&gt;k;
+				A -= *t;
 				continue;
 
 			case BPF_ALU|BPF_MUL|BPF_X:
-				A *= X;
-				continue;
-
 			case BPF_ALU|BPF_MUL|BPF_K:
-				A *= X;
+				A *= *t;
 				continue;
 
 			case BPF_ALU|BPF_DIV|BPF_X:
-				if(X == 0)
-					return (0);
-				A /= X;
-				continue;
-
 			case BPF_ALU|BPF_DIV|BPF_K:
-				if(fentry-&gt;k == 0)
+				if(*t == 0)
 					return (0);
-				A /= fentry-&gt;k;
+				A /= *t;
 				continue;
 
 			case BPF_ALU|BPF_AND|BPF_X:
-				A &amp;= X;
-				continue;
-
 			case BPF_ALU|BPF_AND|BPF_K:
-				A &amp;= fentry-&gt;k;
+				A &amp;= *t;
 				continue;
 
 			case BPF_ALU|BPF_OR|BPF_X:
-				A |= X;
-				continue;
-
 			case BPF_ALU|BPF_OR|BPF_K:
-				A |= fentry-&gt;k;
+				A |= *t;
 				continue;
 
 			case BPF_ALU|BPF_LSH|BPF_X:
-				A &lt;&lt;= X;
-				continue;
-
 			case BPF_ALU|BPF_LSH|BPF_K:
-				A &lt;&lt;= fentry-&gt;k;
+				A &lt;&lt;= *t;
 				continue;
 
 			case BPF_ALU|BPF_RSH|BPF_X:
-				A &gt;&gt;= X;
-				continue;
-
 			case BPF_ALU|BPF_RSH|BPF_K:
-				A &gt;&gt;= fentry-&gt;k;
+				A &gt;&gt;= *t;
 				continue;
 
 			case BPF_ALU|BPF_NEG:
@@ -192,62 +148,26 @@
 			case BPF_JMP|BPF_JSET|BPF_X:
 				pc += (A &amp; X) ? fentry-&gt;jt : fentry-&gt;jf;
 				continue;
-
 			case BPF_LD|BPF_W|BPF_ABS:
 				k = fentry-&gt;k;
-load_w:
-				if(k+sizeof(u32) &lt;= len) {
-					A = ntohl(*(u32*)&amp;data[k]);
-					continue;
-				}
-				if (k&lt;0) {
-					u8 *ptr;
-
-					if (k&gt;=SKF_AD_OFF)
-						break;
-					if ((ptr = load_pointer(skb, k)) != NULL) {
-						A = ntohl(*(u32*)ptr);
-						continue;
-					}
-				}
-				return 0;
+				if(k + sizeof(long) &gt; len)
+					return (0);
+				A = ntohl(*(long*)&amp;data[k]);
+				continue;
 
 			case BPF_LD|BPF_H|BPF_ABS:
 				k = fentry-&gt;k;
-load_h:
-				if(k + sizeof(u16) &lt;= len) {
-					A = ntohs(*(u16*)&amp;data[k]);
-					continue;
-				}
-				if (k&lt;0) {
-					u8 *ptr;
-
-					if (k&gt;=SKF_AD_OFF)
-						break;
-					if ((ptr = load_pointer(skb, k)) != NULL) {
-						A = ntohs(*(u16*)ptr);
-						continue;
-					}
-				}
-				return 0;
+				if(k + sizeof(short) &gt; len)
+					return (0);
+				A = ntohs(*(short*)&amp;data[k]);
+				continue;
 
 			case BPF_LD|BPF_B|BPF_ABS:
 				k = fentry-&gt;k;
-load_b:
-				if(k &lt; len) {
-					A = data[k];
-					continue;
-				}
-				if (k&lt;0) {
-					u8 *ptr;
-
-					if (k&gt;=SKF_AD_OFF)
-						break;
-					if ((ptr = load_pointer(skb, k)) != NULL) {
-						A = *ptr;
-						continue;
-					}
-				}
+				if(k &gt;= len)
+					return (0);
+				A = data[k];
+				continue;
 
 			case BPF_LD|BPF_W|BPF_LEN:
 				A = len;
@@ -257,23 +177,35 @@
 				X = len;
 				continue;
 
-			case BPF_LD|BPF_W|BPF_IND:
+                      case BPF_LD|BPF_W|BPF_IND:
 				k = X + fentry-&gt;k;
-				goto load_w;
+				if(k + sizeof(u32) &gt; len)
+					return (0);
+                                A = ntohl(*(u32 *)&amp;data[k]);
+				continue;
 
                        case BPF_LD|BPF_H|BPF_IND:
 				k = X + fentry-&gt;k;
-				goto load_h;
+				if(k + sizeof(u16) &gt; len)
+					return (0);
+				A = ntohs(*(u16*)&amp;data[k]);
+				continue;
 
                        case BPF_LD|BPF_B|BPF_IND:
 				k = X + fentry-&gt;k;
-				goto load_b;
+				if(k &gt;= len)
+					return (0);
+				A = data[k];
+				continue;
 
 			case BPF_LDX|BPF_B|BPF_MSH:
+				/*
+				 *	Hack for BPF to handle TOS etc
+				 */
 				k = fentry-&gt;k;
 				if(k &gt;= len)
 					return (0);
-				X = (data[k] &amp; 0xf) &lt;&lt; 2;
+				X = (data[fentry-&gt;k] &amp; 0xf) &lt;&lt; 2;
 				continue;
 
 			case BPF_LD|BPF_IMM:
@@ -284,7 +216,7 @@
 				X = fentry-&gt;k;
 				continue;
 
-			case BPF_LD|BPF_MEM:
+                       case BPF_LD|BPF_MEM:
 				A = mem[fentry-&gt;k];
 				continue;
 
@@ -314,29 +246,15 @@
 				mem[fentry-&gt;k] = X;
 				continue;
 
+
+
 			default:
 				/* Invalid instruction counts as RET */
 				return (0);
 		}
-
-		/* Handle ancillary data, which are impossible
-		   (or very difficult) to get parsing packet contents.
-		 */
-		switch (k-SKF_AD_OFF) {
-		case SKF_AD_PROTOCOL:
-			A = htons(skb-&gt;protocol);
-			continue;
-		case SKF_AD_PKTTYPE:
-			A = skb-&gt;pkt_type;
-			continue;
-		case SKF_AD_IFINDEX:
-			A = skb-&gt;dev-&gt;ifindex;
-			continue;
-		default:
-			return 0;
-		}
 	}
 
+	printk(KERN_ERR &quot;Filter ruleset ran off the end.\n&quot;);
 	return (0);
 }
 
@@ -361,17 +279,13 @@
                  
                 ftest = &amp;filter[pc];
 		if(BPF_CLASS(ftest-&gt;code) == BPF_JMP)
-		{
+		{	
 			/*
 			 *	But they mustn't jump off the end.
 			 */
 			if(BPF_OP(ftest-&gt;code) == BPF_JA)
 			{
-				/* Note, the large ftest-&gt;k might cause
-				   loops. Compare this with conditional
-				   jumps below, where offsets are limited. --ANK (981016)
-				 */
-				if (ftest-&gt;k &gt;= (unsigned)(flen-pc-1))
+				if(pc + ftest-&gt;k + 1&gt;= (unsigned)flen)
 					return (-EINVAL);
 			}
                         else
@@ -388,18 +302,17 @@
                  *	Check that memory operations use valid addresses.
                  */
                  
-                if (ftest-&gt;k &gt;= BPF_MEMWORDS)
+                if(ftest-&gt;k &lt;0 || ftest-&gt;k &gt;= BPF_MEMWORDS)
                 {
                 	/*
                 	 *	But it might not be a memory operation...
                 	 */
-			switch (ftest-&gt;code) {
-			case BPF_ST:	
-			case BPF_STX:	
-			case BPF_LD|BPF_MEM:	
-			case BPF_LDX|BPF_MEM:	
+                	 
+                	if (BPF_CLASS(ftest-&gt;code) == BPF_ST)
                 		return -EINVAL;
-			}
+			if((BPF_CLASS(ftest-&gt;code) == BPF_LD) &amp;&amp; 
+				(BPF_MODE(ftest-&gt;code) == BPF_MEM))
+	                        	return (-EINVAL);
 		}
         }
 
@@ -419,35 +332,34 @@
 
 int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk)
 {
-	struct sk_filter *fp; 
-	unsigned int fsize = sizeof(struct sock_filter) * fprog-&gt;len;
+	struct sock_filter *fp, *old_filter; 
+	int fsize = sizeof(struct sock_filter) * fprog-&gt;len;
 	int err;
 
 	/* Make sure new filter is there and in the right amounts. */
-        if (fprog-&gt;filter == NULL || fprog-&gt;len &gt; BPF_MAXINSNS)
+        if(fprog-&gt;filter == NULL || fprog-&gt;len == 0 || fsize &gt; BPF_MAXINSNS)
                 return (-EINVAL);
 
-	fp = (struct sk_filter *)sock_kmalloc(sk, fsize+sizeof(*fp), GFP_KERNEL);
-	if(fp == NULL)
-		return (-ENOMEM);
-
-	if (copy_from_user(fp-&gt;insns, fprog-&gt;filter, fsize)) {
-		sock_kfree_s(sk, fp, fsize+sizeof(*fp)); 
-		return -EFAULT;
-	}
+	if((err = sk_chk_filter(fprog-&gt;filter, fprog-&gt;len))==0)
+	{
+		/* If existing filter, remove it first */
+		if(sk-&gt;filter)
+		{
+			old_filter = sk-&gt;filter_data;
+			kfree_s(old_filter, (sizeof(old_filter) * sk-&gt;filter));
+			sk-&gt;filter_data = NULL;
+		}
 
-	atomic_set(&amp;fp-&gt;refcnt, 1);
-	fp-&gt;len = fprog-&gt;len;
+		fp = (struct sock_filter *)kmalloc(fsize, GFP_KERNEL);
+		if(fp == NULL)
+			return (-ENOMEM);
 
-	if ((err = sk_chk_filter(fp-&gt;insns, fp-&gt;len))==0) {
-		struct sk_filter *old_fp = sk-&gt;filter;
-		sk-&gt;filter = fp;
-		wmb();
-		fp = old_fp;
-	}
+		memset(fp,0,sizeof(*fp));
+		memcpy(fp, fprog-&gt;filter, fsize);	/* Copy instructions */
 
-	if (fp)
-		sk_filter_release(sk, fp);
+		sk-&gt;filter = fprog-&gt;len;	/* Number of filter blocks */
+		sk-&gt;filter_data = fp;		/* Filter instructions */
+	}
 
 	return (err);
 }
--- pristine/net/core/sock.c	Tue Feb 23 18:45:45 1999
+++ linux-2.2.2-axp/net/core/sock.c	Tue Feb 23 20:16:35 1999
@@ -155,6 +155,10 @@
 	int err;
 	struct linger ling;
 	int ret = 0;
+
+#ifdef CONFIG_FILTER
+	struct sock_fprog fprog;
+#endif
 	
 	/*
 	 *	Options without arguments
@@ -252,13 +256,12 @@
 
 		case SO_PRIORITY:
 			if (val &gt;= 0 &amp;&amp; val &lt;= 7) 
-			{
-				if(val==7 &amp;&amp; !capable(CAP_NET_ADMIN))
-					return -EPERM;
 				sk-&gt;priority = val;
-			}			
+			else
+				return(-EINVAL);
 			break;
 
+
 		case SO_LINGER:
 			if(optlen&lt;sizeof(ling))
 				return -EINVAL;	/* 1003.1g */
@@ -307,12 +310,10 @@
 				if (optlen &gt; IFNAMSIZ) 
 					optlen = IFNAMSIZ; 
 				if (copy_from_user(devname, optval, optlen))
-					return -EFAULT;
-
+				    return -EFAULT;
+				    
 				/* Remove any cached route for this socket. */
-				lock_sock(sk);
 				dst_release(xchg(&amp;sk-&gt;dst_cache, NULL));
-				release_sock(sk);
 
 				if (devname[0] == '\0') {
 					sk-&gt;bound_dev_if = 0;
@@ -330,32 +331,30 @@
 
 #ifdef CONFIG_FILTER
 		case SO_ATTACH_FILTER:
-			ret = -EINVAL;
-			if (optlen == sizeof(struct sock_fprog)) {
-				struct sock_fprog fprog;
+			if(optlen &lt; sizeof(struct sock_fprog))
+				return -EINVAL;
 
+			if(copy_from_user(&amp;fprog, optval, sizeof(fprog)))
+			{
 				ret = -EFAULT;
-				if (copy_from_user(&amp;fprog, optval, sizeof(fprog)))
-					break;
-
-				ret = sk_attach_filter(&amp;fprog, sk);
+				break;
 			}
+
+			ret = sk_attach_filter(&amp;fprog, sk);
 			break;
 
 		case SO_DETACH_FILTER:
-                        if(sk-&gt;filter) {
-				struct sk_filter *filter;
-
-				filter = sk-&gt;filter;
-
-				sk-&gt;filter = NULL;
-				wmb();
-				
-				if (filter)
-					sk_filter_release(sk, filter);
+                        if(sk-&gt;filter)
+			{
+				fprog.filter = sk-&gt;filter_data;
+				kfree_s(fprog.filter, (sizeof(fprog.filter) * sk-&gt;filter));
+				sk-&gt;filter_data = NULL;
+				sk-&gt;filter = 0;
 				return 0;
 			}
-			return -ENOENT;
+			else
+				return -EINVAL;
+			break;
 #endif
 		/* We implement the SO_SNDLOWAT etc to
 		   not be settable (1003.1g 5.3) */
@@ -504,16 +503,6 @@
 {
 	if (sk-&gt;destruct)
 		sk-&gt;destruct(sk);
-
-#ifdef CONFIG_FILTER
-	if (sk-&gt;filter) {
-		sk_filter_release(sk, sk-&gt;filter);
-		sk-&gt;filter = NULL;
-	}
-#endif
-
-	if (atomic_read(&amp;sk-&gt;omem_alloc))
-		printk(KERN_DEBUG &quot;sk_free: optmem leakage (%d bytes) detected.\n&quot;, atomic_read(&amp;sk-&gt;omem_alloc));
 
 	kmem_cache_free(sk_cachep, sk);
 }
--- pristine/net/ipv4/tcp_ipv4.c	Tue Feb 23 18:45:46 1999
+++ linux-2.2.2-axp/net/ipv4/tcp_ipv4.c	Tue Feb 23 20:16:35 1999
@@ -1323,10 +1323,6 @@
 		newsk-&gt;pair = NULL;
 		skb_queue_head_init(&amp;newsk-&gt;back_log);
 		skb_queue_head_init(&amp;newsk-&gt;error_queue);
-#ifdef CONFIG_FILTER
-		if (newsk-&gt;filter)
-			sk_filter_charge(newsk, newsk-&gt;filter);
-#endif
 
 		/* Now setup tcp_opt */
 		newtp = &amp;(newsk-&gt;tp_pinfo.af_tcp);
@@ -1557,10 +1553,12 @@
 
 int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
 {
-
 #ifdef CONFIG_FILTER
-	if (sk-&gt;filter &amp;&amp; sk_filter(skb, sk-&gt;filter))
-		goto discard;
+	if (sk-&gt;filter)
+	{
+		if (sk_filter(skb, sk-&gt;filter_data, sk-&gt;filter))
+			goto discard;
+	}
 #endif /* CONFIG_FILTER */
 
 	/* 
<P>
<P><PRE>
-- 
To unsubscribe: send e-mail to <A HREF="mailto:axp-list-request@redhat.com?subject=Re:%20[patches]%20patch-2.2.2-nonx86,patch-2.2.2-filter">axp-list-request@redhat.com</A> with
'unsubscribe' as the subject.  Do not send it to <A HREF="mailto:axp-list@redhat.com?subject=Re:%20[patches]%20patch-2.2.2-nonx86,patch-2.2.2-filter">axp-list@redhat.com</A>
</PRE>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Previous message:</STRONG> <A HREF="0701.html">Bernard Chew, Lai Wan: "RE: Video cards"</A>
<!-- nextthread="start" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.landfield.com/hypermail/">hypermail 2.0b3</A> 
on <EM>Tue Feb 23 1999 - 19:00:29 PST</EM>
</EM>
</SMALL>
</BODY>
</HTML>
