<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"> 
     <HTML> 
     <HEAD> 
     <TITLE>Axp-List Archive</TITLE> 
     <LINK REV="made" HREF="mailto:mailto-address"> 
     <HEAD> 
     <BODY BGCOLOR="#DC9D33" TEXT="#000000" LINK="#DD0000" ALINK="#CC0000" VLINK="#CC0000">
		<CENTER>  <!--#exec cgi="/cgi-bin/banmat1.cgi"--></CENTER>

     <H1 ALIGN=CENTER>Axp-List Archive<BR> alphaev6 page copy and clear</H1> 
	
<!-- received="Thu Feb 08 18:19:04 2001" -->
<!-- isoreceived="20010209021904" -->
<!-- sent="Thu, 8 Feb 2001 10:06:13 -0800" -->
<!-- isosent="20010208180613" -->
<!-- name="Richard Henderson" -->
<!-- email="rth@twiddle.net" -->
<!-- subject="alphaev6 page copy and clear" -->
<!-- id="20010208100613.A2056@twiddle.net" -->
<STRONG>Subject: </STRONG>alphaev6 page copy and clear<BR>
<STRONG>From: </STRONG>Richard Henderson (<EM>rth@twiddle.net</EM>)<BR>
<STRONG>Date: </STRONG>Thu Feb  8 10:06:13 2001
<P>
<UL>
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.shtml#574">[ date ]</A>
<A HREF="index.shtml#574">[ thread ]</A>
<A HREF="subject.shtml#574">[ subject ]</A>
<A HREF="author.shtml#574">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0575.shtml">Hankinson, Jeremy: "RE: Oracle on Alpha Linux"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0573.shtml">Mike Foley: "RE: Wine on Alpha"</A>
<!-- nextthread="start" -->
<!-- reply="end" -->
</UL>
<HR>
<!-- body="start" -->
<P>
The effects of which are most visible here:
<BR>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pipe AF    TCP  File   Mmap  Bcopy  Bcopy  Mem   Mem
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNIX      reread reread (libc) (hand) read write
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---- ---- ---- ------ ------ ------ ------ ---- -----
<BR>
up1000 before   232  192  177    120    269    202    183  268   213
<BR>
up1000 after    347  247  193    143    269    202    183  269   214
<BR>
<P><P>r~
<BR>
<P><P>diff -ruNp linux/arch/alpha/kernel/alpha_ksyms.c 2.4.1/arch/alpha/kernel/alpha_ksyms.c
<BR>
--- linux/arch/alpha/kernel/alpha_ksyms.c	Sun Nov 12 19:27:11 2000
<BR>
+++ 2.4.1/arch/alpha/kernel/alpha_ksyms.c	Wed Feb  7 18:12:24 2001
<BR>
@@ -98,6 +98,8 @@ EXPORT_SYMBOL(__memcpy);
<BR>
&nbsp;EXPORT_SYMBOL(__memset);
<BR>
&nbsp;EXPORT_SYMBOL(__memsetw);
<BR>
&nbsp;EXPORT_SYMBOL(__constant_c_memset);
<BR>
+EXPORT_SYMBOL(copy_page);
<BR>
+EXPORT_SYMBOL(clear_page);
<BR>
&nbsp;
<BR>
&nbsp;EXPORT_SYMBOL(__direct_map_base);
<BR>
&nbsp;EXPORT_SYMBOL(__direct_map_size);
<BR>
diff -ruNp linux/arch/alpha/lib/Makefile 2.4.1/arch/alpha/lib/Makefile
<BR>
--- linux/arch/alpha/lib/Makefile	Sat Dec 30 11:13:36 2000
<BR>
+++ 2.4.1/arch/alpha/lib/Makefile	Wed Feb  7 18:10:05 2001
<BR>
@@ -42,6 +42,8 @@ OBJS =	__divqu.o __remqu.o __divlu.o __r
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(ev6)strncpy_from_user.o \
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(ev67)strlen_user.o \
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(ev6)csum_ipv6_magic.o \
<BR>
+	$(ev6)clear_page.o \
<BR>
+	$(ev6)copy_page.o \
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcasecmp.o \
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fpreg.o \
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback_srm.o srm_puts.o srm_printk.o
<BR>
diff -ruNp linux/arch/alpha/lib/clear_page.S 2.4.1/arch/alpha/lib/clear_page.S
<BR>
--- linux/arch/alpha/lib/clear_page.S	Wed Dec 31 16:00:00 1969
<BR>
+++ 2.4.1/arch/alpha/lib/clear_page.S	Wed Feb  7 17:11:56 2001
<BR>
@@ -0,0 +1,39 @@
<BR>
+/*
<BR>
+ * arch/alpha/lib/clear_page.S
<BR>
+ *
<BR>
+ * Zero an entire page.
<BR>
+ */
<BR>
+
<BR>
+	.text
<BR>
+	.align 4
<BR>
+	.global clear_page
<BR>
+	.ent clear_page
<BR>
+clear_page:
<BR>
+	.prologue 0
<BR>
+
<BR>
+	lda	$0,128
<BR>
+	nop
<BR>
+	unop
<BR>
+	nop
<BR>
+
<BR>
+1:	stq	$31,0($16)
<BR>
+	stq	$31,8($16)
<BR>
+	stq	$31,16($16)
<BR>
+	stq	$31,24($16)
<BR>
+
<BR>
+	stq	$31,32($16)
<BR>
+	stq	$31,40($16)
<BR>
+	stq	$31,48($16)
<BR>
+	subq	$0,1,$0
<BR>
+
<BR>
+	stq	$31,56($16)
<BR>
+	addq	$16,64,$16
<BR>
+	unop
<BR>
+	bne	$0,1b
<BR>
+
<BR>
+	ret
<BR>
+	nop
<BR>
+	unop
<BR>
+	nop
<BR>
+
<BR>
+	.end clear_page
<BR>
diff -ruNp linux/arch/alpha/lib/copy_page.S 2.4.1/arch/alpha/lib/copy_page.S
<BR>
--- linux/arch/alpha/lib/copy_page.S	Wed Dec 31 16:00:00 1969
<BR>
+++ 2.4.1/arch/alpha/lib/copy_page.S	Wed Feb  7 17:22:01 2001
<BR>
@@ -0,0 +1,49 @@
<BR>
+/*
<BR>
+ * arch/alpha/lib/copy_page.S
<BR>
+ *
<BR>
+ * Copy an entire page.
<BR>
+ */
<BR>
+
<BR>
+	.text
<BR>
+	.align 4
<BR>
+	.global copy_page
<BR>
+	.ent copy_page
<BR>
+copy_page:
<BR>
+	.prologue 0
<BR>
+
<BR>
+	lda	$18,128
<BR>
+	nop
<BR>
+	unop
<BR>
+	nop
<BR>
+
<BR>
+1:	ldq	$0,0($17)
<BR>
+	ldq	$1,8($17)
<BR>
+	ldq	$2,16($17)
<BR>
+	ldq	$3,24($17)
<BR>
+
<BR>
+	ldq	$4,32($17)
<BR>
+	ldq	$5,40($17)
<BR>
+	ldq	$6,48($17)
<BR>
+	ldq	$7,56($17)
<BR>
+
<BR>
+	stq	$0,0($16)
<BR>
+	subq	$18,1,$18
<BR>
+	stq	$1,8($16)
<BR>
+	addq	$17,64,$17
<BR>
+
<BR>
+	stq	$2,16($16)
<BR>
+	stq	$3,24($16)
<BR>
+	stq	$4,32($16)
<BR>
+	stq	$5,40($16)
<BR>
+
<BR>
+	stq	$6,48($16)
<BR>
+	stq	$7,56($16)
<BR>
+	addq	$16,64,$16
<BR>
+	bne	$18, 1b
<BR>
+
<BR>
+	ret
<BR>
+	nop
<BR>
+	unop
<BR>
+	nop
<BR>
+
<BR>
+	.end copy_page
<BR>
diff -ruNp linux/arch/alpha/lib/ev6-clear_page.S 2.4.1/arch/alpha/lib/ev6-clear_page.S
<BR>
--- linux/arch/alpha/lib/ev6-clear_page.S	Wed Dec 31 16:00:00 1969
<BR>
+++ 2.4.1/arch/alpha/lib/ev6-clear_page.S	Wed Feb  7 17:11:42 2001
<BR>
@@ -0,0 +1,54 @@
<BR>
+/*
<BR>
+ * arch/alpha/lib/ev6-clear_page.S
<BR>
+ *
<BR>
+ * Zero an entire page.
<BR>
+ */
<BR>
+
<BR>
+        .text
<BR>
+        .align 4
<BR>
+        .global clear_page
<BR>
+        .ent clear_page
<BR>
+clear_page:
<BR>
+        .prologue 0
<BR>
+
<BR>
+	lda	$0,128
<BR>
+	lda	$1,125
<BR>
+	addq	$16,64,$2
<BR>
+	addq	$16,128,$3
<BR>
+
<BR>
+	addq	$16,192,$17
<BR>
+	wh64	($16)
<BR>
+	wh64	($2)
<BR>
+	wh64	($3)
<BR>
+
<BR>
+1:	wh64	($17)
<BR>
+	stq	$31,0($16)
<BR>
+	subq	$0,1,$0
<BR>
+	subq	$1,1,$1
<BR>
+
<BR>
+	stq	$31,8($16)
<BR>
+	stq	$31,16($16)
<BR>
+	addq	$17,64,$2
<BR>
+	nop
<BR>
+
<BR>
+	stq	$31,24($16)
<BR>
+	stq	$31,32($16)
<BR>
+	cmovgt	$1,$2,$17
<BR>
+	nop
<BR>
+
<BR>
+	stq	$31,40($16)
<BR>
+	stq	$31,48($16)
<BR>
+	nop
<BR>
+	nop
<BR>
+
<BR>
+	stq	$31,56($16)
<BR>
+	addq	$16,64,$16
<BR>
+	nop
<BR>
+	bne	$0,1b
<BR>
+
<BR>
+	ret
<BR>
+	nop
<BR>
+	nop
<BR>
+	nop
<BR>
+
<BR>
+	.end clear_page
<BR>
diff -ruNp linux/arch/alpha/lib/ev6-copy_page.S 2.4.1/arch/alpha/lib/ev6-copy_page.S
<BR>
--- linux/arch/alpha/lib/ev6-copy_page.S	Wed Dec 31 16:00:00 1969
<BR>
+++ 2.4.1/arch/alpha/lib/ev6-copy_page.S	Wed Feb  7 18:42:28 2001
<BR>
@@ -0,0 +1,203 @@
<BR>
+/*
<BR>
+ * arch/alpha/lib/ev6-copy_page.S
<BR>
+ *
<BR>
+ * Copy an entire page.
<BR>
+ */
<BR>
+
<BR>
+/* The following comparison of this routine vs the normal copy_page.S
<BR>
+   was written by an unnamed ev6 hardware designer and forwarded to me
<BR>
+   via Steven Hobbs &lt;hobbs@steven.zko.dec.com&gt;.
<BR>
+ 
<BR>
+   First Problem: STQ overflows.
<BR>
+   -----------------------------
<BR>
+
<BR>
+	It would be nice if EV6 handled every resource overflow efficiently,
<BR>
+	but for some it doesn't.  Including store queue overflows.  It causes
<BR>
+	a trap and a restart of the pipe.
<BR>
+
<BR>
+	To get around this we sometimes use (to borrow a term from a VSSAD
<BR>
+	researcher) &quot;aeration&quot;.  The idea is to slow the rate at which the
<BR>
+	processor receives valid instructions by inserting nops in the fetch
<BR>
+	path.  In doing so, you can prevent the overflow and actually make
<BR>
+	the code run faster.  You can, of course, take advantage of the fact
<BR>
+	that the processor can fetch at most 4 aligned instructions per cycle.
<BR>
+
<BR>
+	I inserted enough nops to force it to take 10 cycles to fetch the
<BR>
+	loop code.  In theory, EV6 should be able to execute this loop in
<BR>
+	9 cycles but I was not able to get it to run that fast -- the initial
<BR>
+	conditions were such that I could not reach this optimum rate on
<BR>
+	(chaotic) EV6.  I wrote the code such that everything would issue
<BR>
+	in order. 
<BR>
+
<BR>
+   Second Problem: Dcache index matches.
<BR>
+   -------------------------------------
<BR>
+
<BR>
+	If you are going to use this routine on random aligned pages, there
<BR>
+	is a 25% chance that the pages will be at the same dcache indices.
<BR>
+	This results in many nasty memory traps without care.
<BR>
+
<BR>
+	The solution is to schedule the prefetches to avoid the memory
<BR>
+	conflicts.  I schedule the wh64 prefetches farther ahead of the
<BR>
+	read prefetches to avoid this problem.
<BR>
+
<BR>
+   Third Problem: Needs more prefetching.
<BR>
+   --------------------------------------
<BR>
+
<BR>
+	In order to improve the code I added deeper prefetching to take the
<BR>
+	most advantage of EV6's bandwidth.
<BR>
+
<BR>
+	I also prefetched the read stream. Note that adding the read prefetch
<BR>
+	forced me to add another cycle to the inner-most kernel - up to 11
<BR>
+	from the original 8 cycles per iteration.  We could improve performance
<BR>
+	further by unrolling the loop and doing multiple prefetches per cycle.
<BR>
+
<BR>
+   I think that the code below will be very robust and fast code for the
<BR>
+   purposes of copying aligned pages.  It is slower when both source and
<BR>
+   destination pages are in the dcache, but it is my guess that this is
<BR>
+   less important than the dcache miss case.  */
<BR>
+
<BR>
+
<BR>
+	.text
<BR>
+	.align 4
<BR>
+	.global copy_page
<BR>
+	.ent copy_page
<BR>
+copy_page:
<BR>
+	.prologue 0
<BR>
+
<BR>
+	/* Prefetch 5 read cachelines; write-hint 10 cache lines.  */
<BR>
+	wh64	($16)
<BR>
+	ldl	$31,0($17)
<BR>
+	ldl	$31,64($17)
<BR>
+	lda	$1,1*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	ldl	$31,128($17)
<BR>
+	ldl	$31,192($17)
<BR>
+	lda	$1,2*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	ldl	$31,256($17)
<BR>
+	lda	$18,118
<BR>
+	lda	$1,3*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	nop
<BR>
+	lda	$1,4*64($16)
<BR>
+	lda	$2,5*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	wh64	($2)
<BR>
+	lda	$1,6*64($16)
<BR>
+	lda	$2,7*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	wh64	($2)
<BR>
+	lda	$1,8*64($16)
<BR>
+	lda	$2,9*64($16)
<BR>
+
<BR>
+	wh64	($1)
<BR>
+	wh64	($2)
<BR>
+	lda	$19,10*64($16)
<BR>
+	nop
<BR>
+
<BR>
+	/* Main prefetching/write-hinting loop.  */
<BR>
+1:	ldq	$0,0($17)
<BR>
+	ldq	$1,8($17)
<BR>
+	unop
<BR>
+	unop
<BR>
+
<BR>
+	unop
<BR>
+	unop
<BR>
+	ldq	$2,16($17)
<BR>
+	ldq	$3,24($17)
<BR>
+
<BR>
+	ldq	$4,32($17)
<BR>
+	ldq	$5,40($17)
<BR>
+	unop
<BR>
+	unop
<BR>
+
<BR>
+	unop
<BR>
+	unop
<BR>
+	ldq	$6,48($17)
<BR>
+	ldq	$7,56($17)
<BR>
+
<BR>
+	ldl	$31,320($17)
<BR>
+	unop
<BR>
+	unop
<BR>
+	unop
<BR>
+
<BR>
+	/* This gives the extra cycle of aeration above the minimum.  */
<BR>
+	unop			
<BR>
+	unop
<BR>
+	unop
<BR>
+	unop
<BR>
+
<BR>
+	wh64	($19)
<BR>
+	unop
<BR>
+	unop
<BR>
+	unop
<BR>
+
<BR>
+	stq	$0,0($16)
<BR>
+	subq	$18,1,$18
<BR>
+	stq	$1,8($16)
<BR>
+	unop
<BR>
+
<BR>
+	unop
<BR>
+	stq	$2,16($16)
<BR>
+	addq	$17,64,$17
<BR>
+	stq	$3,24($16)
<BR>
+
<BR>
+	stq	$4,32($16)
<BR>
+	stq	$5,40($16)
<BR>
+	addq	$19,64,$19
<BR>
+	unop
<BR>
+
<BR>
+	stq	$6,48($16)
<BR>
+	stq	$7,56($16)
<BR>
+	addq	$16,64,$16
<BR>
+	bne	$18, 1b
<BR>
+
<BR>
+	/* Prefetch the final 5 cache lines of the read stream.  */
<BR>
+	lda	$18,10
<BR>
+	ldl	$31,320($17)
<BR>
+	ldl	$31,384($17)
<BR>
+	ldl	$31,448($17)
<BR>
+
<BR>
+	ldl	$31,512($17)
<BR>
+	ldl	$31,576($17)
<BR>
+	nop
<BR>
+	nop
<BR>
+
<BR>
+	/* Non-prefetching, non-write-hinting cleanup loop for the
<BR>
+	   final 10 cache lines.  */
<BR>
+2:	ldq	$0,0($17)
<BR>
+	ldq	$1,8($17)
<BR>
+	ldq	$2,16($17)
<BR>
+	ldq	$3,24($17)
<BR>
+
<BR>
+	ldq	$4,32($17)
<BR>
+	ldq	$5,40($17)
<BR>
+	ldq	$6,48($17)
<BR>
+	ldq	$7,56($17)
<BR>
+
<BR>
+	stq	$0,0($16)
<BR>
+	subq	$18,1,$18
<BR>
+	stq	$1,8($16)
<BR>
+	addq	$17,64,$17
<BR>
+
<BR>
+	stq	$2,16($16)
<BR>
+	stq	$3,24($16)
<BR>
+	stq	$4,32($16)
<BR>
+	stq	$5,40($16)
<BR>
+
<BR>
+	stq	$6,48($16)
<BR>
+	stq	$7,56($16)
<BR>
+	addq	$16,64,$16
<BR>
+	bne	$18, 2b
<BR>
+
<BR>
+	ret
<BR>
+	nop
<BR>
+	unop
<BR>
+	nop
<BR>
+
<BR>
+	.end copy_page
<BR>
diff -ruNp linux/include/asm-alpha/page.h 2.4.1/include/asm-alpha/page.h
<BR>
--- linux/include/asm-alpha/page.h	Wed Aug  9 13:46:01 2000
<BR>
+++ 2.4.1/include/asm-alpha/page.h	Wed Feb  7 17:16:23 2001
<BR>
@@ -12,64 +12,10 @@
<BR>
&nbsp;
<BR>
&nbsp;#define STRICT_MM_TYPECHECKS
<BR>
&nbsp;
<BR>
-/*
<BR>
- * A _lot_ of the kernel time is spent clearing pages, so
<BR>
- * do this as fast as we possibly can. Also, doing this
<BR>
- * as a separate inline function (rather than memset())
<BR>
- * results in clearer kernel profiles as we see _who_ is
<BR>
- * doing page clearing or copying.
<BR>
- */
<BR>
-static inline void clear_page(void * page)
<BR>
-{
<BR>
-	unsigned long count = PAGE_SIZE/64;
<BR>
-	unsigned long *ptr = (unsigned long *)page;
<BR>
-
<BR>
-	do {
<BR>
-		ptr[0] = 0;
<BR>
-		ptr[1] = 0;
<BR>
-		ptr[2] = 0;
<BR>
-		ptr[3] = 0;
<BR>
-		count--;
<BR>
-		ptr[4] = 0;
<BR>
-		ptr[5] = 0;
<BR>
-		ptr[6] = 0;
<BR>
-		ptr[7] = 0;
<BR>
-		ptr += 8;
<BR>
-	} while (count);
<BR>
-}
<BR>
-
<BR>
+extern void clear_page(void *page);
<BR>
&nbsp;#define clear_user_page(page, vaddr)	clear_page(page)
<BR>
&nbsp;
<BR>
-static inline void copy_page(void * _to, void * _from)
<BR>
-{
<BR>
-	unsigned long count = PAGE_SIZE/64;
<BR>
-	unsigned long *to = (unsigned long *)_to;
<BR>
-	unsigned long *from = (unsigned long *)_from;
<BR>
-
<BR>
-	do {
<BR>
-		unsigned long a,b,c,d,e,f,g,h;
<BR>
-		a = from[0];
<BR>
-		b = from[1];
<BR>
-		c = from[2];
<BR>
-		d = from[3];
<BR>
-		e = from[4];
<BR>
-		f = from[5];
<BR>
-		g = from[6];
<BR>
-		h = from[7];
<BR>
-		count--;
<BR>
-		from += 8;
<BR>
-		to[0] = a;
<BR>
-		to[1] = b;
<BR>
-		to[2] = c;
<BR>
-		to[3] = d;
<BR>
-		to[4] = e;
<BR>
-		to[5] = f;
<BR>
-		to[6] = g;
<BR>
-		to[7] = h;
<BR>
-		to += 8;
<BR>
-	} while (count);
<BR>
-}
<BR>
-
<BR>
+extern void copy_page(void * _to, void * _from);
<BR>
&nbsp;#define copy_user_page(to, from, vaddr)	copy_page(to, from)
<BR>
&nbsp;
<BR>
&nbsp;#ifdef STRICT_MM_TYPECHECKS
<BR>
<P><P><P>_______________________________________________
<BR>
Axp-list mailing list
<BR>
Axp-list@redhat.com
<BR>
https://listman.redhat.com/mailman/listinfo/axp-list
<BR>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="0575.shtml">Hankinson, Jeremy: "RE: Oracle on Alpha Linux"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="0573.shtml">Mike Foley: "RE: Wine on Alpha"</A>
<!-- nextthread="start" -->
<!-- reply="end" -->
</UL>
<!-- trailer="footer" -->
<HR> 
     <P> 
     <SMALL> 
     <EM> 
     This archive was generated by  <A HREF="http://www.landfield.com/hypermail">hypermail version 2a22 </A> on Sat Mar  3 12:54:56 2001 PST <BR>
	Send any problems or questions about this archive to <A HREF="mailto:webmaster@alphalinux.org">webmaster@alphalinux.org</A>. 
     </EM> 
     </SMALL> 
     </BODY> 
     </HTML> 
