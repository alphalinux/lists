<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>axp-list: Re: Wanna Buy My Alpha?</TITLE>
<META NAME="Author" CONTENT="J C Lawrence (claw@under.engr.sgi.com)">
<META NAME="Subject" CONTENT="Re: Wanna Buy My Alpha?">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1 ALIGN=CENTER>Re: Wanna Buy My Alpha?</H1>
<HR>
<P>
<!-- received="Thu Jan 21 01:01:44 1999 PST" -->
<!-- sent="Wed, 20 Jan 1999 17:00:49 -0800" -->
<!-- name="J C Lawrence" -->
<!-- email="claw@under.engr.sgi.com" -->
<!-- subject="Re: Wanna Buy My Alpha?" -->
<!-- id="199901210100.RAA93044@under.engr.sgi.com" -->
<!-- inreplyto="designer_7@hotmail.com" -->
<STRONG>J C Lawrence</STRONG> (<A HREF="mailto:claw@under.engr.sgi.com?subject=Re:%20Wanna%20Buy%20My%20Alpha?"><EM>claw@under.engr.sgi.com</EM></A>)<BR>
<EM>Wed, 20 Jan 1999 17:00:49 -0800</EM>
<P>
<UL>
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#1054">[ date ]</A>
<A HREF="index.html#1054">[ thread ]</A>
<A HREF="subject.html#1054">[ subject ]</A>
<A HREF="author.html#1054">[ author ]</A>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="1055.html">J C Lawrence: "Re: Wanna Buy My Alpha?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="1053.html">Ray Schultz: "RedHat 5.2 Install question"</A>
<!-- nextthread="start" -->
</UL>
<HR>
<!-- body="start" -->
<P>
On Tue, 19 Jan 1999 19:38:27 PST 
<BR>
Designer 7&lt;<A HREF="mailto:designer_7@hotmail.com?subject=Re:%20Wanna%20Buy%20My%20Alpha?">designer_7@hotmail.com</A>&gt; wrote:
<BR>
<P><EM>&gt; Hmm... I can see that certain hacks being architecture dependant,
</EM><BR>
<EM>&gt; but what does little-endian have to do with it? I mean, I know
</EM><BR>
<EM>&gt; byte ordering is significant in the tcp/ip implementation, but
</EM><BR>
<EM>&gt; AFAIK, Linux/Alpha is little-endian anyway... I don't know about
</EM><BR>
<EM>&gt; Digital Unix though?
</EM><BR>
<P>I mistyped.  The advantage is because Alpha is (by default)
<BR>
little-endian and not big endian.  The advantage has nothing to do
<BR>
with network order, but to do with the expected interpretation of
<BR>
values by the target OS in designing the exploit script.  To take
<BR>
advantage of a buffer overrun (overwrite the return pointer and
<BR>
point it at your own data which you then execute to do whatever),
<BR>
you have to know the following:
<BR>
<P>&nbsp;&nbsp;What does the stack look like on the target machine, and exactly
<BR>
where on the stack is the return pointer?
<BR>
<P>&nbsp;&nbsp;What size are pointers on the target machine (32 or 64 bit)?
<BR>
<P>&nbsp;&nbsp;What is the endianness of the target machine?
<BR>
<P>And then for your jumped-to code that you intend to be executed:
<BR>
<P>&nbsp;&nbsp;What is the instruction set of the target machine?
<BR>
<P>&nbsp;&nbsp;What is the native word-size of the target machine?
<BR>
<P>Not all of these points are always required (not all exploits are
<BR>
stack overflows, and some stack bugs have other weaknesses), however
<BR>
almost all published exploits depends on at least one of these
<BR>
requirements, and in particular (for Linux) depends on x86, 32bit
<BR>
and big endian.
<BR>
<P>Does this mean that an Alpha running the same buggy code is more
<BR>
secure than the Intel box?  Yes and no.  The Alpha is subject to the
<BR>
same exploits, however the pre-canned scripts used by most script
<BR>
kiddies will fail as they expect x86 etc and the script kiddies
<BR>
don't know enough about their hacks to know why they fail or to
<BR>
&quot;fix&quot; them.  Of course an intelligent and educated cracker is still
<BR>
able to touch up the script to crack the Alpha, but we're dealing
<BR>
with a far far smaller public there.
<BR>
<P><EM>&gt; However, without proof, and mere speculation, I would think that
</EM><BR>
<EM>&gt; software ported over from Intel to Alpha are likely to have a
</EM><BR>
<EM>&gt; higher risk of having security holes.
</EM><BR>
<P>I haven't found this to be the case.
<BR>
<P><EM>&gt; Although, the fact that more people have Intels than Alphas,
</EM><BR>
<EM>&gt; probably correlates to more security holes being discovered on
</EM><BR>
<EM>&gt; Intel than on Alpha. However, if many experienced hackers/security
</EM><BR>
<EM>&gt; professionals concentrated on finding holes in Alpha systems, I
</EM><BR>
<EM>&gt; would tend to think that they'd find equally as many holes, if not
</EM><BR>
<EM>&gt; more.
</EM><BR>
<P>Most, not all, holes are generic design or implementation weaknesses 
<BR>
that aren't particular to the host machine.  Buffer overflows really 
<BR>
don't care what the base OS or CPU is, they are still buffer
<BR>
overflows and are _potential_ sources of exploits.  The fact that
<BR>
the base hardware is x86 in one case and Alpha in another typically
<BR>
doesn't matter much (very small exceptions).
<BR>
<P><EM>&gt; I guess my point is, security through obscurity is not a
</EM><BR>
<EM>&gt; philosophy I would go by... at least not these days... when people
</EM><BR>
<EM>&gt; can find bargain deals on systems of most architectures... I got
</EM><BR>
<EM>&gt; my &gt; my 21164a@500Mhz for $500... cheaper than my most of my Intel
</EM><BR>
<EM>&gt; machines.
</EM><BR>
<P>Security is an illusion.  There are no absolutely secure machines
<BR>
that are powered on.  The game is not to make a &quot;secure&quot; machine,
<BR>
but one that is sufficiently difficult to break into.  The whole
<BR>
security game is a cost/benefit ratio.
<BR>
<P>Yes, in any absolute sense security thru obscurity is not a long
<BR>
term wise tactic.  However, in practice, and over the shorter term,
<BR>
it *does* work within certain well known boundaries.
<BR>
<P>My Alpha's are not especially secure machines.  They are *fairly*
<BR>
secure; I close all the obvious and well known holes as well as a
<BR>
few others, but I am not about to make supervising the security of
<BR>
those machines a 24hr a day job.  In the mean time, relying on the
<BR>
behavioural characterisitics of security thru obscurity as it
<BR>
pertains to script kiddies and newly found cracks works well.
<BR>
<P>&nbsp;&nbsp;eg Exploitable buffer overruns were found in bind/named.  For
<BR>
various reasons (out of town) I missed the announcements and didn't
<BR>
upgrade my name servers for about a week.  Friends who run x86 linux
<BR>
boxen also failed to upgrade, and within 36 hours of the exploit
<BR>
being published had root compromises on their boxes.  I merely had a
<BR>
nice big core file and a dead named.
<BR>
<P>&nbsp;&nbsp;Yes, technically I was open to the same exploits they were.
<BR>
However, I merely got a core file and lost name service.  They got
<BR>
root compromises and had to rebuild their systems.
<BR>
<P><PRE>
-- 
J C Lawrence                              Internet: <A HREF="mailto:claw@kanga.nu?subject=Re:%20Wanna%20Buy%20My%20Alpha?">claw@kanga.nu</A>
(Contractor)                             Internet: <A HREF="mailto:coder@kanga.nu?subject=Re:%20Wanna%20Buy%20My%20Alpha?">coder@kanga.nu</A>
---------(*)                    Internet: <A HREF="mailto:claw@under.engr.sgi.com?subject=Re:%20Wanna%20Buy%20My%20Alpha?">claw@under.engr.sgi.com</A>
...Honorary Member of Clan McFud -- Teamer's Avenging Monolith...
<P><PRE>
-- 
To unsubscribe: send e-mail to <A HREF="mailto:axp-list-request@redhat.com?subject=Re:%20Wanna%20Buy%20My%20Alpha?">axp-list-request@redhat.com</A> with
'unsubscribe' as the subject.  Do not send it to <A HREF="mailto:axp-list@redhat.com?subject=Re:%20Wanna%20Buy%20My%20Alpha?">axp-list@redhat.com</A>
</PRE>
<P><!-- body="end" -->
<HR>
<P>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="1055.html">J C Lawrence: "Re: Wanna Buy My Alpha?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="1053.html">Ray Schultz: "RedHat 5.2 Install question"</A>
<!-- nextthread="start" -->
</UL>
<!-- trailer="footer" -->
<HR>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.landfield.com/hypermail/">hypermail 2.0b3</A> 
on <EM>Sun Jan 24 1999 - 14:47:51 PST</EM>
</EM>
</SMALL>
</BODY>
</HTML>
